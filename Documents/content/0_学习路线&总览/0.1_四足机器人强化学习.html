<div class="doc-container"><h1>四足机器人RL路线</h1>
<h2>✅ Week 1：向量 / 矩阵 &amp; Python / Eigen 入门</h2>
<h3>理论：线性代数基础</h3>
<ul>
<li>复习向量、矩阵加减乘、转置</li>
<li>理解点乘、叉乘的几何意义</li>
<li>理解 L2 范数、Frobenius 范数</li>
<li>看完一节线性代数相关资料并做笔记（纸/Markdown）</li>
</ul>
<h3>Python：数值运算练习</h3>
<ul>
<li>用 Numpy 实现：矩阵乘法、转置、求逆</li>
<li>用 np.linalg.norm 计算向量与矩阵范数</li>
<li>用 np.linalg.cond 计算矩阵条件数，并记录几个例子</li>
</ul>
<h3>C++ / Eigen：基础使用</h3>
<ul>
<li>配好一个简单的 CMake + Eigen 工程</li>
<li>写 demo：定义 Matrix3d、Vector3d，做一次矩阵乘法</li>
<li>输出矩阵/向量到控制台，确认编译运行 OK</li>
</ul>
<hr />
<h2>✅ Week 2：SVD / 最小二乘 / 伪逆</h2>
<h3>理论：分解 &amp; LS</h3>
<ul>
<li>了解 EVD / SVD 的用途（稳定求解 / 病态问题）</li>
<li>推一遍最小二乘正规方程（可以看资料+抄一遍）</li>
<li>理解伪逆的概念与作用场景（欠定/超定）</li>
</ul>
<h3>Python：拟合小实验</h3>
<ul>
<li>构造带噪声的一维数据（y = ax + b + noise）</li>
<li>用手算 LS：(A^T A)^-1 A^T b</li>
<li>用 np.linalg.lstsq 求解并对比</li>
<li>用 SVD np.linalg.svd 求伪逆解一次</li>
</ul>
<h3>C++ / Eigen：LS demo</h3>
<ul>
<li>用 Eigen 实现一维 LS 拟合</li>
<li>封装成一个 LeastSquaresFitter 小类</li>
<li>在 main 里调用并打印拟合参数</li>
</ul>
<hr />
<h2>✅ Week 3：FK / IK / Jacobian（Python 版）</h2>
<h3>理论：单腿运动学</h3>
<ul>
<li>画出简化单腿（2/3 关节）示意图</li>
<li>写出 FK 公式（q → foot pos）</li>
<li>理解 IK 几何解 or 数值解</li>
<li>理解 Jacobian 定义：v = J dq</li>
</ul>
<h3>Python：单腿模型</h3>
<ul>
<li>用 Python 写 FK 函数：fk(q) -&gt; x</li>
<li>写简化 IK：给足端位置求关节角（可用数值方法）</li>
<li>写 Jacobian 函数：J(q)</li>
<li>用数值差分验证：J dq ≈ (x(q+dq)-x(q))/dt</li>
</ul>
<h3>小可视化（可选）：</h3>
<ul>
<li>用 matplotlib 简单画出腿在平面位置的若干姿态</li>
</ul>
<hr />
<h2>✅ Week 4：梯度 + 自动求导 + 数值微分</h2>
<h3>理论：微积分与优化基础</h3>
<ul>
<li>复习导数 / 偏导 / 梯度 / 链式法则</li>
<li>理解梯度下降思想（沿负梯度方向走）</li>
<li>知道 Hessian 是“二阶导矩阵”（只需概念）</li>
</ul>
<h3>Python：梯度 &amp; PyTorch</h3>
<ul>
<li>用 Numpy 对 f(x,y)=x² + y² 做梯度下降（手写更新）</li>
<li>用 PyTorch 定义一个 MLP 拟合简单函数（如 sin(x)）</li>
<li>打印某次反向传播后的 grad，看看数值</li>
</ul>
<h3>C++：数值求导小工具</h3>
<ul>
<li>写一个函数：double numerical_grad(std::function<double(double)>, double x)</li>
<li>用差分 (f(x+h)-f(x-h))/(2h) 实现</li>
<li>测试对 f(x)=x², sin(x) 等函数的数值梯度</li>
</ul>
<hr />
<h2>✅ Week 5：动力学直觉 + 简单系统仿真</h2>
<h3>理论：刚体动力学基础</h3>
<ul>
<li>理解质心、转动惯量</li>
<li>理解“力 → 加速度”、“力矩 → 角加速度”</li>
<li>看一眼 M(q) q̈ + C(q,q̇) q̇ + g(q) = τ 结构，理解每项物理含义</li>
</ul>
<h3>Python：倒立摆/摆杆仿真</h3>
<ul>
<li>写一个单摆或倒立摆的动力学方程</li>
<li>用 RK4 数值积分模拟一小段时间</li>
<li>画出角度/角速度随时间变化曲线</li>
</ul>
<h3>C++：动力学库调用（可选）</h3>
<ul>
<li>如果环境有 pinocchio/RBDL，调用一次 inverse dynamics</li>
<li>打印某个姿态下的 M、C、g，建立直觉</li>
</ul>
<hr />
<h2>✅ Week 6：IMU / Encoder / 足端接触（仿真思路）</h2>
<h3>理论：传感器基础</h3>
<ul>
<li>IMU：测量角速度、加速度、姿态的基本概念</li>
<li>Encoder：位置/速度获取方式</li>
<li>足端接触：力阈值 + 速度判据</li>
</ul>
<h3>Python：接触检测模拟</h3>
<ul>
<li>生成一段伪 foot pos/vel/force 时间序列</li>
<li>写一个简单接触检测函数：is_contact(pos_z, vel_z, force)</li>
<li>画 contact=true/false 随时间变化</li>
</ul>
<h3>C++：接触估计类</h3>
<ul>
<li>写 class FootContactEstimator：<ul>
<li>输入：pos_z, vel_z, force</li>
<li>输出：bool contact</li>
</ul>
</li>
<li>在 main 中读几组测试数据，打印结果</li>
</ul>
<hr />
<h2>✅ Week 7：EKF 概念 + 一维示例</h2>
<h3>理论：EKF 高层结构</h3>
<ul>
<li>理解“预测 + 更新”两步</li>
<li>知道状态、控制、观测的含义</li>
<li>不追矩阵推导，只理解框架</li>
</ul>
<h3>Python：1D EKF demo</h3>
<ul>
<li>状态：位置、速度</li>
<li>动力学：匀速运动/匀加速模型</li>
<li>观测：位置 + 噪声</li>
<li>实现简化版 EKF，画真实/观测/估计对比</li>
</ul>
<h3>C++：EKF 框架类</h3>
<ul>
<li>写 class SimpleEKF：<ul>
<li>成员：x, P</li>
<li>函数：predict(), update(z)</li>
</ul>
</li>
<li>用伪数据跑一段，打印估计结果（先不对复杂系统用）</li>
</ul>
<hr />
<h2>✅ Week 8：整理机器人基础 C++ 工程</h2>
<h3>本周目标：把前面 C++ 相关代码整理成可复用工具库</h3>
<h3>任务清单：</h3>
<ul>
<li>建一个 quadruped_utils 工程（CMake管理）</li>
<li>整理类：<ul>
<li>LegKinematics</li>
<li>FootContactEstimator</li>
<li>SimpleEKF（即使还未完整）</li>
</ul>
</li>
<li>写简单 demo 程序调用这些类，统一风格和命名</li>
<li>写一份 README，记录这些工具类的用途</li>
</ul>
<hr />
<h2>✅ Week 9：RL 基础 + CartPole</h2>
<h3>理论：RL 基本概念</h3>
<ul>
<li>MDP：S, A, R, P, γ 的含义</li>
<li>Value / Q / Policy 的区别</li>
<li>Actor-Critic 的直觉</li>
</ul>
<h3>Python：CartPole 小实验</h3>
<ul>
<li>用 Gym + Python 实现 Q-learning 或 DQN 或 A2C</li>
<li>跑通训练，让 CartPole 站稳</li>
<li>画 reward 随训练步数的曲线</li>
</ul>
<h3>C++：环境抽象（可选）</h3>
<ul>
<li>写一个抽象类 Env：reset(), step(action)</li>
<li>实现一个最简单的 1D 环境，练习接口设计</li>
</ul>
<hr />
<h2>✅ Week 10–11：PPO 实战（连续控制）</h2>
<p>这两周任务比较重，可以按自己节奏分散到 10/11 两周完成。</p>
<h3>理论：PPO &amp; Advantage</h3>
<ul>
<li>看 PPO 公式：clip loss / value loss / entropy</li>
<li>理解 advantage（GAE 只需直觉）</li>
</ul>
<h3>Python：PPO 实现</h3>
<ul>
<li>用 PyTorch 实现 PPO 框架：<ul>
<li>policy/value 网络</li>
<li>rollout 收集</li>
<li>计算 advantage</li>
<li>更新参数</li>
</ul>
</li>
<li>选一个连续动作环境（如 Pendulum）训练成功</li>
<li>调试学习率、clip 参数、entropy 系数，看收敛情况变化</li>
<li>记录一版“自己可用的 PPO 模板”代码</li>
</ul>
<h3>C++：日志工具</h3>
<ul>
<li>写一个 C++ 日志类，把数据（时间、状态、命令）存成 CSV</li>
<li>用 Python 画出这些 CSV 的曲线</li>
</ul>
<hr />
<h2>✅ Week 12：把 RL 思路映射到四足任务</h2>
<h3>理论：四足 RL 任务结构梳理</h3>
<ul>
<li>列出当前四足 RL 的：<ul>
<li>obs 含哪些量（姿态、速度、foot 等）</li>
<li>action 是什么（期望关节角/foot force/增量等）</li>
<li>reward 分为哪几类（姿态/速度/foot/能耗/平滑等）</li>
</ul>
</li>
</ul>
<h3>Python：阅读现有训练代码 + 注释</h3>
<ul>
<li>通读目前在用的四足 PPO 训练脚本</li>
<li>在代码里加中文注释，标出：<ul>
<li>obs 构造</li>
<li>reward 各部分</li>
<li>action 如何映射到电机/关节</li>
</ul>
</li>
</ul>
<h3>C++：Sim2Real 接口草图</h3>
<ul>
<li>写头文件草稿：<ul>
<li>struct RLObservation</li>
<li>struct RLAction</li>
</ul>
</li>
<li>设计 ROS/LCM 消息或内部接口大致结构</li>
</ul>
<hr />
<h2>✅ Week 13–14：Gait / Phase / Duty Factor</h2>
<h3>理论：腿足步态</h3>
<ul>
<li>理解 Trot / Pace / Bound 的相位关系</li>
<li>理解 Phase / Duty Factor 概念</li>
<li>了解 stance/swing 对稳定性的影响</li>
</ul>
<h3>Python：gait generator</h3>
<ul>
<li>写函数：get_leg_phase(gait_type, t)</li>
<li>输出 4 条腿在一个周期内 swing/stance 序列</li>
<li>用 matplotlib 画四条腿的“条形图步态图”</li>
</ul>
<h3>C++：GaitScheduler</h3>
<ul>
<li>实现 class GaitScheduler：<ul>
<li>输入：时间 t 或相位 φ</li>
<li>输出：每腿 swing/stance 标志</li>
</ul>
</li>
<li>在一个伪控制循环中调用，打印结果检查</li>
</ul>
<hr />
<h2>✅ Week 15：Foot clearance 轨迹</h2>
<h3>理论：足端轨迹</h3>
<ul>
<li>认识典型足端 z(t) 曲线：起步、抬脚、落地</li>
<li>明白落地速度过大易引发冲击/抖动</li>
</ul>
<h3>Python：z(t) 设计</h3>
<ul>
<li>为 swing 相设计 z(t)：<ul>
<li>起始 0，高度 h，周期 T，峰值在 0.5T</li>
<li>可用三次或五次多项式</li>
</ul>
</li>
<li>画出 z(t)、dz/dt 曲线，控制落地速度不要太大</li>
</ul>
<h3>C++：FootTrajectoryGenerator</h3>
<ul>
<li>class FootTrajectoryGenerator：<ul>
<li>输入：相位 φ、步长、步高</li>
<li>输出：foot pos/vel</li>
</ul>
</li>
<li>在 main 中跑一个周期，打印/保存用于可视化</li>
</ul>
<hr />
<h2>✅ Week 16：Foot Placement &amp; 奖励几何直觉</h2>
<h3>理论：Raibert 落脚点</h3>
<ul>
<li>理解公式结构：x_foot = x_com + k * v 类似关系</li>
<li>知道如何基于速度误差调整落脚点</li>
</ul>
<h3>Python：落脚点模拟</h3>
<ul>
<li>写 compute_foot_target(v_des, v_now) 函数</li>
<li>不同 v_des/v_now 下，画出 foot target 分布</li>
<li>思考两种情况：<ul>
<li>加速：落点应该偏前</li>
<li>减速：落点应该偏后</li>
</ul>
</li>
</ul>
<h3>C++：FootPlacementPlanner</h3>
<ul>
<li>实现 C++ 版 FootPlacementPlanner 接口</li>
<li>集成到 gait + foot trajectory 结构体中（先在仿真逻辑级别）。</li>
</ul>
<hr />
<h2>✅ Week 17–18：仿真环境定制（Isaac Gym / Legged-Gym）</h2>
<h3>理论：仿真系统结构</h3>
<ul>
<li>理解 Isaac Gym / Legged-Gym 中：<ul>
<li>env 数量</li>
<li>root_state_tensor/dof_state_tensor</li>
<li>每步仿真流程（step → obs → act → reward）</li>
</ul>
</li>
</ul>
<h3>Python：环境走读 &amp; 改造</h3>
<ul>
<li>跑通完整训练一次（可短一点）</li>
<li>通读环境定义代码，理解：<ul>
<li>obs 构造</li>
<li>reward 项</li>
<li>action → 电机命令映射</li>
</ul>
</li>
<li>尝试修改一两个 reward 项，看行为变化</li>
<li>尝试修改 obs（如加/减某个量），观察训练表现变化</li>
</ul>
<h3>C++：规划 Sim2Real 对接</h3>
<ul>
<li>根据仿真中 obs/action 定义，整理出真机侧应提供/接收的字段（姿态、速度、foot contact 等）</li>
</ul>
<hr />
<h2>✅ Week 19：Domain Randomization（随机化）</h2>
<h3>理论：Sim2Real gap &amp; 随机化</h3>
<ul>
<li>理解随机化作用：对抗建模误差（质量、摩擦、噪声）</li>
<li>分析当前系统中可能的误差来源</li>
</ul></div>